# Smart Contract Security Audit Report

**Project**: Thurin - Privacy-Preserving mDL Verification System
**Repository**: /Users/benwoodall/Development/thurin
**Commit**: `b7c23cd` (main branch)
**Auditor**: Claude (AI-Assisted Audit)
**Date**: 2026-01-19

---

## Executive Summary

### Scope

| Item | Details |
|------|---------|
| Contracts | ThurinSBT.sol, ThurinVerifier.sol, ThurinPoints.sol, IHonkVerifier.sol |
| Lines of Code | ~621 LOC (excluding HonkVerifier.sol auto-generated) |
| Solidity Version | 0.8.28 |
| Framework | Foundry |
| Chain Target | Ethereum Mainnet / Sepolia |

### Findings Summary

| Severity | Count |
|----------|-------|
| Critical | 0 |
| High | 0 |
| Medium | 2 |
| Low | 3 |
| Informational | 4 |
| **Total** | **9** |

### Overall Assessment

The Thurin Protocol demonstrates a well-designed architecture for privacy-preserving identity verification using ZK proofs. The codebase follows security best practices including:
- Two-step ownership transfer (Ownable2Step from OpenZeppelin)
- Soulbound token implementation preventing transfers
- Nullifier-based sybil resistance
- Proof freshness validation with 1-hour window
- Trusted IACA root management
- Event emission for admin parameter changes
- Minimum validity period enforcement (1 day)
- Renewal mechanism allowing existing SBT holders to extend validity

The contracts are concise, well-documented, and have comprehensive test coverage (79 tests passing including fuzz tests). No critical or high severity vulnerabilities were identified. The medium severity findings relate to potential DoS vectors and missing zero-address validation that should be addressed before mainnet deployment.

---

## Scope & Methodology

### In-Scope Contracts

| File | LOC | Description |
|------|-----|-------------|
| `src/ThurinSBT.sol` | 244 | Soulbound ERC721 token with ZK proof verification |
| `src/ThurinVerifier.sol` | 98 | Privacy-preserving verification for dApps |
| `src/ThurinPoints.sol` | 207 | Points tracking for users and dApps |
| `src/interfaces/IHonkVerifier.sol` | 16 | Interface for ZK verifier |

### Out of Scope

- `src/HonkVerifier.sol` - Auto-generated ZK verifier (100k+ LOC)
- Test files and scripts
- Frontend applications
- Off-chain ZK circuit implementation

### Methodology

1. **Automated Analysis**: Foundry build verification, test execution (79 tests passing)
2. **Manual Review**: Line-by-line code review following security checklist
3. **Threat Modeling**: Identification of attack vectors and trust assumptions

---

## Assumptions & Trust Model

### Trusted Entities

| Entity | Trust Level | Capabilities |
|--------|-------------|--------------|
| Owner (ThurinSBT) | Fully Trusted | Add/remove IACA roots, set prices, set validity period, withdraw funds, transfer ownership |
| Owner (ThurinPoints) | Fully Trusted | Transfer ownership |
| HonkVerifier | Fully Trusted | ZK proof verification (assumed correct) |

### Key Assumptions

1. The HonkVerifier contract correctly verifies ZK proofs
2. IACA roots are legitimate state authority public key hashes
3. Users generate proofs locally and submit them on-chain
4. The bound_address in proofs corresponds to msg.sender

### Limitations

- This audit does not guarantee the absence of vulnerabilities
- AI-assisted analysis may miss subtle or novel attack vectors
- The ZK circuit implementation was not reviewed
- Economic/game-theoretic attacks may require specialized analysis

---

## Findings Summary

| ID | Title | Severity | Status | SWC |
|----|-------|----------|--------|-----|
| [M-01] | DoS Risk in getTopDapps via Unbounded External Calls | Medium | Open | SWC-128 |
| [M-02] | Missing Zero-Address Validation in Constructors | Medium | Open | - |
| [L-01] | Renewal Bypasses Nullifier Check Allowing Double-Mint Vectors | Low | Open | - |
| [L-02] | setMintPrice Allows Setting Price to Zero | Low | Open | - |
| [L-03] | Block Timestamp Dependency for Proof Freshness | Low | Open | SWC-116 |
| [I-01] | Centralization Risk - Single Owner Pattern | Info | Open | - |
| [I-02] | No Withdrawal Pattern for Excess ETH | Info | Open | - |
| [I-03] | registeredDapps Array Can Grow Unboundedly | Info | Open | - |
| [I-04] | Consider Adding Emergency Pause Functionality | Info | Open | - |

---

## Detailed Findings

### [M-01] DoS Risk in getTopDapps via Unbounded External Calls

**Severity**: Medium

**SWC**: SWC-128 (DoS With Block Gas Limit)

**Location**: `src/ThurinPoints.sol:161-194`

#### Description

The `getTopDapps` function iterates over all registered dApps and makes external calls to `verifier.dappVerificationCount()` for each one. With a large number of registered dApps, this function could exceed block gas limits and become unusable.

```solidity
function getTopDapps(uint256 limit) external view returns (
    address[] memory dapps,
    uint256[] memory verifications
) {
    uint256 count = registeredDapps.length;
    // ...
    for (uint256 i = 0; i < limit; i++) {
        // ...
        for (uint256 j = 0; j < count; j++) {  // O(n) for each iteration
            if (!used[j]) {
                uint256 val = verifier.dappVerificationCount(registeredDapps[j]); // External call
                // ...
            }
        }
        // ...
    }
}
```

The algorithm is O(n * limit) where n is the number of registered dApps, with external calls in the inner loop.

#### Impact

- View function becomes uncallable when dApp count grows large
- Any off-chain systems relying on this function will fail
- Users cannot view leaderboard data

This is Medium because it affects a view function and does not impact core protocol functionality (minting, verifying).

#### Recommendation

1. Cache verification counts in storage when claiming points
2. Implement pagination for large datasets
3. Move leaderboard computation off-chain using events

```solidity
// Option 1: Cache counts
mapping(address => uint256) public cachedVerificationCount;

function claimDappPoints(address dapp) external returns (uint256 claimed) {
    uint256 totalVerifications = verifier.dappVerificationCount(dapp);
    cachedVerificationCount[dapp] = totalVerifications; // Cache for leaderboard
    // ... rest of function
}

// Option 2: Pagination
function getTopDapps(uint256 offset, uint256 limit) external view returns (...) {
    // Return subset of dApps with pagination
}
```

#### Verification Test

```solidity
function test_getTopDapps_handlesLargeDappCount() public {
    // Register many dApps
    for (uint256 i = 0; i < 1000; i++) {
        address dapp = makeAddr(string(abi.encodePacked("dapp", i)));
        vm.prank(dapp);
        points.registerDapp(string(abi.encodePacked("Dapp ", i)));
    }

    // This should complete without reverting
    uint256 gasStart = gasleft();
    (address[] memory dapps,) = points.getTopDapps(10);
    uint256 gasUsed = gasStart - gasleft();

    // Assert reasonable gas usage (adjust threshold as needed)
    assertLt(gasUsed, 5_000_000);
}
```

---

### [M-02] Missing Zero-Address Validation in Constructors

**Severity**: Medium

**Location**: `src/ThurinSBT.sol:70-72`, `src/ThurinVerifier.sol:25-28`, `src/ThurinPoints.sol:37-40`

#### Description

The constructors do not validate that the passed addresses are non-zero. If deployed with zero addresses, the contracts would be permanently broken since `honkVerifier`, `sbt`, and `verifier` are immutable.

```solidity
// ThurinSBT.sol
constructor(address _honkVerifier) ERC721("Thurin SBT", "THURIN") Ownable(msg.sender) {
    honkVerifier = IHonkVerifier(_honkVerifier); // No zero check
}

// ThurinVerifier.sol
constructor(address _honkVerifier, address _sbt) {
    honkVerifier = IHonkVerifier(_honkVerifier); // No zero check
    sbt = ThurinSBT(_sbt); // No zero check
}

// ThurinPoints.sol
constructor(address _sbt, address _verifier) Ownable(msg.sender) {
    sbt = ThurinSBT(_sbt); // No zero check
    verifier = ThurinVerifier(_verifier); // No zero check
}
```

#### Impact

- Deployment with zero addresses would require redeployment
- All calls to the verifier would fail
- Low likelihood (deployment scripts should catch this) but high impact if it occurs

#### Recommendation

Add explicit zero-address checks in constructors:

```solidity
error ZeroAddress();

constructor(address _honkVerifier) ERC721("Thurin SBT", "THURIN") Ownable(msg.sender) {
    if (_honkVerifier == address(0)) revert ZeroAddress();
    honkVerifier = IHonkVerifier(_honkVerifier);
}
```

#### Verification Test

```solidity
function test_constructor_revertsOnZeroAddress() public {
    vm.expectRevert(ThurinSBT.ZeroAddress.selector);
    new ThurinSBT(address(0));
}
```

---

### [L-01] Renewal Bypasses Nullifier Check Allowing Different Document Renewal

**Severity**: Low

**Location**: `src/ThurinSBT.sol:219-266`

#### Description

The `renew()` function intentionally bypasses the `nullifierUsed` check, allowing users to renew their SBT with any valid proof. This design choice means:
1. A user could transfer their mDL to someone else
2. The new person generates a proof with a different nullifier
3. They call `renew()` on the original SBT holder's behalf (if they have wallet access)

```solidity
function renew(...) external payable {
    // Must already have an SBT
    if (balanceOf(msg.sender) == 0) revert NoSBTToRenew();

    // ... validation ...

    // NOTE: No nullifierUsed check - same nullifier allowed for renewal

    // Build public inputs...
    // Verify ZK proof
    if (!honkVerifier.verify(proof, publicInputs)) revert InvalidProof();

    // Reset validity timestamp
    tokenMintTimestamp[tokenId] = block.timestamp;
}
```

This is by design to allow renewal with the same mDL (same nullifier), but the lack of nullifier binding means the proof could come from a different document entirely.

#### Impact

- Low impact: requires wallet compromise to exploit
- The `bound_address` in the proof must match `msg.sender`, so the user must control the wallet
- Does not allow creating new SBTs, only extending existing ones

#### Recommendation

Consider tracking the original nullifier and requiring it matches on renewal:

```solidity
mapping(uint256 => bytes32) public tokenNullifier;

function mint(...) {
    // ...
    tokenNullifier[tokenId] = nullifier;
}

function renew(bytes32 nullifier, ...) {
    uint256 tokenId = userTokenId[msg.sender];
    require(tokenNullifier[tokenId] == nullifier, "Wrong nullifier");
    // ...
}
```

Or document that this is intentional to allow mDL replacement scenarios.

---

### [L-02] setMintPrice Allows Setting Price to Zero

**Severity**: Low

**Location**: `src/ThurinSBT.sol:218-221`

#### Description

The `setMintPrice` function has no minimum value validation. The owner could set the mint price to zero, allowing free minting after the early adopter tiers are exhausted.

```solidity
function setMintPrice(uint256 _mintPrice) external onlyOwner {
    uint256 oldPrice = mintPrice;
    mintPrice = _mintPrice;
    emit MintPriceUpdated(oldPrice, _mintPrice);
}
```

#### Impact

- Owner could accidentally set price to 0
- Could be intentional (free mints) but should be explicit

#### Recommendation

Consider adding a minimum price or requiring explicit confirmation for zero:

```solidity
uint256 public constant MIN_MINT_PRICE = 0.0001 ether;

function setMintPrice(uint256 _mintPrice) external onlyOwner {
    if (_mintPrice > 0 && _mintPrice < MIN_MINT_PRICE) revert PriceTooLow();
    // Zero is allowed for free mints, but requires explicit intent
    uint256 oldPrice = mintPrice;
    mintPrice = _mintPrice;
    emit MintPriceUpdated(oldPrice, _mintPrice);
}
```

---

### [L-03] Block Timestamp Dependency for Proof Freshness

**Severity**: Low

**SWC**: SWC-116 (Block Timestamp Dependence)

**Location**: `src/ThurinSBT.sol:117-118`, `src/ThurinVerifier.sol:59-60`

#### Description

The proof freshness checks rely on `block.timestamp`:

```solidity
if (proofTimestamp > block.timestamp) revert ProofFromFuture();
if (proofTimestamp < block.timestamp - PROOF_VALIDITY_PERIOD) revert ProofExpired();
```

Miners/validators can manipulate `block.timestamp` by up to ~15 seconds. This could allow slightly expired proofs to be accepted or valid proofs to be rejected.

#### Impact

- Minimal practical impact given the 1-hour validity window
- Miners would need to collude with attackers for no clear benefit
- The 1-hour buffer provides sufficient tolerance

#### Recommendation

The current 1-hour window provides sufficient buffer. Document this assumption. For higher-security deployments, consider:
- Using block numbers instead of timestamps
- Adding a small buffer to the freshness check

---

### [I-01] Centralization Risk - Single Owner Pattern

**Severity**: Informational

**Location**: `src/ThurinSBT.sol`, `src/ThurinPoints.sol`

#### Description

Both contracts use a single owner address for all administrative functions. If this address is compromised or its private key lost, the protocol faces significant risk:

- Compromised owner can drain all collected fees
- Compromised owner can add malicious IACA roots
- Lost key means no ability to manage trusted roots or withdraw funds

#### Recommendation

Consider:
1. Using a multisig wallet (e.g., Gnosis Safe) as owner
2. Implementing a timelock for sensitive operations
3. Adding role-based access control for different functions

---

### [I-02] No Withdrawal Pattern for Excess ETH

**Severity**: Informational

**Location**: `src/ThurinSBT.sol:102-172`

#### Description

The `mint` function accepts ETH but only checks for minimum payment. Any excess ETH above `getMintPrice()` is retained by the contract and not refunded to the user.

```solidity
if (msg.value < getMintPrice()) revert InsufficientPayment();
// Excess ETH not refunded
```

#### Impact

Users who accidentally overpay lose their excess ETH. While small amounts, this could be significant for user experience.

#### Recommendation

Either refund excess ETH or use `==` instead of `<`:

```solidity
// Option 1: Exact payment required
if (msg.value != getMintPrice()) revert IncorrectPayment();

// Option 2: Refund excess
uint256 price = getMintPrice();
if (msg.value < price) revert InsufficientPayment();
if (msg.value > price) {
    (bool success,) = payable(msg.sender).call{value: msg.value - price}("");
    if (!success) revert RefundFailed();
}
```

---

### [I-03] registeredDapps Array Can Grow Unboundedly

**Severity**: Informational

**Location**: `src/ThurinPoints.sol:29, 116`

#### Description

The `registeredDapps` array grows with each registration and is never pruned. While this doesn't directly cause issues (aside from M-01), it represents unbounded state growth.

```solidity
address[] public registeredDapps;

function registerDapp(string calldata name) external {
    // ...
    registeredDapps.push(msg.sender); // Grows indefinitely
    // ...
}
```

#### Recommendation

Consider:
- Adding a registration fee to discourage spam registrations
- Implementing a maximum registration cap
- Allowing dApps to unregister and remove themselves from the array

---

### [I-04] Consider Adding Emergency Pause Functionality

**Severity**: Informational

**Location**: All contracts

#### Description

None of the contracts implement a pause mechanism. In case of discovered vulnerabilities or attacks, there's no way to halt operations while fixes are deployed.

#### Recommendation

Consider implementing OpenZeppelin's `Pausable` pattern for critical functions:

```solidity
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";

contract ThurinSBT is ERC721, Pausable {
    function mint(...) external payable whenNotPaused returns (uint256) {
        // ...
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
```

---

## Verification Plan

### Tests to Add

| Finding | Test Description | Priority |
|---------|-----------------|----------|
| [M-01] | Gas limit test for getTopDapps with 1000+ dApps | High |
| [M-02] | Constructor revert on zero addresses | High |
| [L-01] | Renewal flow test (when implemented) | Medium |
| [L-02] | Zero price mint behavior | Low |

### Invariants to Enforce

```solidity
// Suggested invariant tests
function invariant_TotalSupplyMatchesUserBalances() public {
    // Sum of all user balances should equal totalSupply
    uint256 totalBalance = 0;
    // ... iterate users
    assertEq(totalBalance, sbt.totalSupply());
}

function invariant_NullifierCanOnlyBeUsedOnce() public {
    // Once a nullifier is marked used, it stays used
    // No mints should succeed with previously used nullifiers
}

function invariant_PointsNeverDecrease() public {
    // User points should only increase or stay the same
    // dApp points should only increase or stay the same
}

function invariant_VerificationCountMatchesClaims() public {
    // claimedVerifications[dapp] <= verifier.dappVerificationCount(dapp)
}
```

### Monitoring Recommendations

| Metric | Alert Threshold | Rationale |
|--------|----------------|-----------|
| Large ETH withdrawals | >1 ETH | Monitor for unauthorized access |
| IACA root additions | Any | Critical security parameter |
| Ownership transfers | Any | Immediate alert required |
| Unusual mint volume | >100/hour | Could indicate exploit or bot activity |
| Failed verification ratio | >20% | May indicate proof generation issues |

---

## Appendix

### A. Tools Used

- Foundry 0.8.28 (build & test)
- Manual code review

### B. SWC References

| SWC | Title | Findings |
|-----|-------|----------|
| SWC-116 | Block Timestamp Dependence | [L-03] |
| SWC-128 | DoS With Block Gas Limit | [M-01] |

### C. Positive Observations

1. **Two-step ownership transfer**: Contracts inherit from OpenZeppelin's `Ownable2Step`, preventing accidental ownership loss
2. **Good use of immutable variables**: `honkVerifier`, `sbt`, `verifier` are immutable, preventing upgrade attacks
3. **Soulbound implementation correct**: ERC721 transfer restrictions properly implemented in `_update` override
4. **Proof freshness checks**: Both mint and verify functions check for expired/future proofs with 1-hour window
5. **Nullifier-based Sybil resistance**: Prevents double-minting with same identity
6. **Event emission for admin changes**: `MintPriceUpdated`, `RenewalPriceUpdated`, `ValidityPeriodUpdated`, `IACARootAdded`, `IACARootRemoved` events provide transparency
7. **Minimum validity period**: `MIN_VALIDITY_PERIOD = 1 days` prevents setting validity to zero
8. **Clean code structure**: Good separation of concerns across contracts
9. **Comprehensive test suite**: 79 tests with fuzz testing coverage, including integration tests with real ZK proofs
10. **Custom errors**: Gas-efficient error handling with descriptive errors
11. **Token ID 0 referral handling**: Uses `type(uint256).max` as sentinel for no-referral, allowing token 0 to be a valid referrer
12. **Renewal mechanism**: Allows expired SBTs to be renewed with fresh proofs, maintaining user continuity
13. **Tiered pricing**: Early adopters get discounted rates (OG_PRICE, KINDA_COOL_PRICE) incentivizing early adoption
14. **Privacy-preserving verification**: ThurinVerifier intentionally emits no events to protect user privacy

### D. Disclosure

This audit was performed by Claude, an AI assistant. While comprehensive automated and manual analysis was performed, AI-assisted audits should be supplemented with human expert review for critical deployments.

---

*Generated by Solidity Audit Assistant - 2026-01-19*
